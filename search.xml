<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Conductor</title>
      <link href="/public/2019/10/05/conductor-study/"/>
      <url>/public/2019/10/05/conductor-study/</url>
      
        <content type="html"><![CDATA[<p>由于工作需要，业务代码内耦合的业务流程越来越多，迫切需要一个好的服务编排引擎。经过调研，Conductor是一个经过实际检验非常优秀的服务编排引擎。经过几周的探索，终于把项目Run起来了。详细的调研结果见后文<br><a id="more"></a></p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="1-Conductor架构图"><a href="#1-Conductor架构图" class="headerlink" title="1.Conductor架构图"></a>1.Conductor架构图</h2><p><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/conductor-system.png" alt="1"></p><h2 id="2-任务生命周期"><a href="#2-任务生命周期" class="headerlink" title="2.任务生命周期"></a>2.任务生命周期</h2><p><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/worker-life.png" alt="2"></p><h2 id="3-调用流程说明"><a href="#3-调用流程说明" class="headerlink" title="3.调用流程说明"></a>3.调用流程说明</h2><ul><li>首先在conductor server上定义task和workflow</li><li>通过接口启动workflow</li><li>编排服务会从存储中取得workflow和其中task的metadata，通过状态机服务判断当前要执行的task放入task queues，并置此task状态为SCHEDULED，等待worker认领</li><li>启动各微服务worker，在worker中声明当前worker对应的task定义的名字</li><li>worker会轮询conductor server，如果发现有同名的任务被放入task queues里，认领此任务，并更新任务状态为IN_PROGRESS，然后开始执行worker内业务逻辑</li><li>worker中业务逻辑执行完后，根据至执行结果，更新任务状态为COMPLETE或FAIL</li><li>conductor server监听此任务如果变为COMPLETE或FAIL执行下一个节点或重试等逻辑操作，如此往复。<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/conductor-source-code.png" alt="2"></li></ul><p>核心代码结构说明</p><ul><li>client层<br>Conductor的使用场景是服务编排，必然会涉及client和server端也就是说在我们的微服务中的服务中可以使用client端来和conductor的server端进行通信，根据不同状态来执行相应任务。</li><li>server层<br>负责conductor server端的启动、工作流任务的启动，由server层调用core层实现分布式状态机控制和任务的调度。</li><li>common层<br>这一层主要涉及的是Task任务和Workflow工作流的元数据和请求参数定义，还有一些工具类。</li><li>core层【核心模块】<br>这一层主要包括的是核心类，包括：事件、队列功能类，还包括任务类型定义、每种类型任务的具体实现逻辑和映射关系，比如分支条件如何进行判断，逻辑表达式如何解析，并行任务如何执行等等。</li><li>jersey层<br>这个主要提供的是Swagger接口展示层，通过启动这个模块可以看到一个接口列表页面，用户可以在界面上操作接口实现任务和工作流元数据的编写和上传，还可以在界面上启动工作流引擎等。</li><li>contribs层<br>亚马逊消息SQS</li><li>es-persistence<br>这一层主要是持久层，根据请求版本不同包括es5和es6二个模块，作用主要包括将任务和工作流元数据保存到es中，还有就是将任务运行时数据进行保存，比如任务执行的状态，执行时间等等。</li><li>mysql-persistence<br>mysql持久层，存储任务和工作流定义的元数据。</li><li>redis-persistence<br>redis持久层，存储任务和工作流定义的元数据。</li><li>conductor-cassandra-persistence<br>cassandra持久层，存储任务和工作流定义的元数据。</li></ul><blockquote><p>grpc、grpc-client、grpc-server是用于支持rpc通信相关的模块</p></blockquote><h2 id="核心类代码【待完善】"><a href="#核心类代码【待完善】" class="headerlink" title="核心类代码【待完善】"></a>核心类代码【待完善】</h2><h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><ul><li>依赖框架：Guice</li><li>mysql：flyway</li><li>servlet容器：jetty</li><li>java:jdk1.8</li><li>构建工具：gradle（原始项目）–&gt;maven（现在）</li><li>待完善……<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1></li></ul><h2 id="从github上获取项目"><a href="#从github上获取项目" class="headerlink" title="从github上获取项目"></a>从github上获取项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Netflix/conductor.git</span><br></pre></td></tr></table></figure><h2 id="gradle项目转maven项目"><a href="#gradle项目转maven项目" class="headerlink" title="gradle项目转maven项目"></a>gradle项目转maven项目</h2><ul><li>前端项目：<a href="http://gitlab.creditease.corp/loanplatformchannel/channel-conductor-ui.git" target="_blank" rel="noopener">http://gitlab.creditease.corp/loanplatformchannel/channel-conductor-ui.git</a></li><li>后端项目（转maven）：<a href="http://gitlab.creditease.corp/loanplatformchannel/channel-conductor.git" target="_blank" rel="noopener">http://gitlab.creditease.corp/loanplatformchannel/channel-conductor.git</a></li></ul><blockquote><p>特别注意：gradle转完maven项目后，存在大量包冲突，推荐一个插件“Maven Helper”，非常好用。</p></blockquote><h2 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h2><ul><li><p>前端项目启动</p><ul><li>安装nodejs</li><li>安装gulp</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install gulp --save-dev </span><br><span class="line">cnpm install --save-dev</span><br></pre></td></tr></table></figure><ul><li>启动项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp watch</span><br></pre></td></tr></table></figure><ul><li>项目启动后，访问地址：<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a></li></ul></li><li><p>后端项目启动</p><ul><li>下载jetty安装包，并配置jetty启动</li><li>下载elasticsearch安装包，并且启动elasticsearch服务</li><li>下载kibana，安装后，启动服务，访问地址：<a href="http://localhost:5601，用于管理es数据" target="_blank" rel="noopener">http://localhost:5601，用于管理es数据</a></li><li>项目启动后，访问地址：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ul></li></ul><blockquote><p>特别注意：1）使用tomcat无法启动conductor，启动时报servlet类型不匹配；</p></blockquote><h1 id="配置工作流"><a href="#配置工作流" class="headerlink" title="配置工作流"></a>配置工作流</h1><h2 id="1-定义任务"><a href="#1-定义任务" class="headerlink" title="1. 定义任务"></a>1. 定义任务</h2><ul><li>使用接口：<a href="http://localhost:8080/api/metadata/taskdefs" target="_blank" rel="noopener">http://localhost:8080/api/metadata/taskdefs</a></li><li><p>HTTP方法:POST<br><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/define-task.png" alt="1"></p></li><li><p>页面查看<br><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/show-task.png" alt="1"></p></li><li><p>入参示例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;user_task&quot;,</span><br><span class="line">        &quot;retryCount&quot;: 3,</span><br><span class="line">        &quot;timeoutSeconds&quot;: 1200,</span><br><span class="line">        &quot;inputKeys&quot;: [</span><br><span class="line">            &quot;type&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;outputKeys&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;name&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;,</span><br><span class="line">        &quot;retryLogic&quot;: &quot;FIXED&quot;,</span><br><span class="line">        &quot;retryDelaySeconds&quot;: 600,</span><br><span class="line">        &quot;responseTimeoutSeconds&quot;: 1200</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;group_task&quot;,</span><br><span class="line">        &quot;retryCount&quot;: 3,</span><br><span class="line">        &quot;timeoutSeconds&quot;: 1200,</span><br><span class="line">        &quot;inputKeys&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;name&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;outputKeys&quot;: [</span><br><span class="line">            &quot;response&quot;,</span><br><span class="line">            &quot;result&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;,</span><br><span class="line">        &quot;retryLogic&quot;: &quot;FIXED&quot;,</span><br><span class="line">        &quot;retryDelaySeconds&quot;: 600,</span><br><span class="line">        &quot;responseTimeoutSeconds&quot;: 1200</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><table><thead><tr><th>领域</th><th>描述</th><th>笔记</th></tr></thead><tbody><tr><td>name</td><td>任务类型</td><td>唯一</td></tr><tr><td>retryCount</td><td>任务标记为失败时尝试重试的次数</td><td></td></tr><tr><td>retryLogic</td><td>重试机制</td><td>看下面的可能值</td></tr><tr><td>timeoutSeconds</td><td>以毫秒为单位的时间，在此之后，如果在转换到IN_PROGRESS状态后未完成任务，则将任务标记为TIMED_OUT</td><td>如果设置为0，则不会超时</td></tr><tr><td>timeoutPolicy</td><td>任务的超时策略</td><td>看下面的可能值</td></tr><tr><td>responseTimeoutSeconds</td><td>如果大于0，则在此时间之后未更新状态时，将重新安排任务。当工作人员轮询任务但由于错误/网络故障而无法完成时很有用。</td><td></td></tr><tr><td>outputKeys</td><td>任务输出的键集。用于记录任务的输出</td></tr></tbody></table><h4 id="重试逻辑"><a href="#重试逻辑" class="headerlink" title="重试逻辑"></a>重试逻辑</h4><ul><li>FIXED ：重新安排任务后的任务 retryDelaySeconds</li><li>EXPONENTIAL_BACKOFF：重新安排之后 retryDelaySeconds * attempNo</li></ul><h4 id="超时政策"><a href="#超时政策" class="headerlink" title="超时政策"></a>超时政策</h4><ul><li>RETRY ：再次重试该任务</li><li>TIME_OUT_WF：工作流程标记为TIMED_OUT并终止</li><li>ALERT_ONLY：注册计数器（task_timeout）</li></ul><h2 id="2-定义工作流【串行工作流】"><a href="#2-定义工作流【串行工作流】" class="headerlink" title="2. 定义工作流【串行工作流】"></a>2. 定义工作流【串行工作流】</h2><ul><li>使用接口：<a href="http://localhost:8080/api/metadata/workflow" target="_blank" rel="noopener">http://localhost:8080/api/metadata/workflow</a></li><li><p>HTTP方法:POST<br><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/define-workflow.png" alt="1"></p></li><li><p>页面查看<br><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/show-workflow.png" alt="1"></p></li></ul><ul><li>入参示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;user_and_group&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;Encodes a file and deploys to CDN&quot;,</span><br><span class="line">    &quot;version&quot;: 1,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;user_task&quot;,</span><br><span class="line">            &quot;taskReferenceName&quot;: &quot;user&quot;,</span><br><span class="line">            &quot;inputParameters&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;$&#123;workflow.input.type&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;type&quot;: &quot;SIMPLE&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;group_task&quot;,</span><br><span class="line">            &quot;taskReferenceName&quot;: &quot;group&quot;,</span><br><span class="line">            &quot;inputParameters&quot;: &#123;</span><br><span class="line">                &quot;id&quot;: &quot;$&#123;user.output.id&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;type&quot;: &quot;SIMPLE&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;outputParameters&quot;: &#123;</span><br><span class="line">        &quot;result&quot;: &quot;$&#123;group.output.result&#125;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;schemaVersion&quot;: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数说明</li></ul><table><thead><tr><th>领域</th><th>描述</th><th>笔记</th></tr></thead><tbody><tr><td>name</td><td>工作流程的名称</td><td></td></tr><tr><td>description</td><td>工作流程的描述性名称</td><td></td></tr><tr><td>version</td><td>用于标识架构版本的数字字段。使用递增数字</td><td>启动工作流程执行时，如果未指定，则使用具有最高版本的定义</td></tr><tr><td>tasks</td><td>一系列任务定义，如下所述。</td><td></td></tr><tr><td>outputParameters</td><td>用于生成工作流输出的JSON模板</td><td>如果未指定，则将输出定义为上次执行的任务的输出</td></tr><tr><td>inputParameters</td><td>输入参数列表。用于记录工作流程所需的输入</td><td>可选的</td></tr></tbody></table><p>其中，tasks工作流中的属性定义要按该顺序执行的任务数组。以下是每项任务所需的强制性最低参数：</p><table><thead><tr><th>领域</th><th>描述</th><th>笔记</th></tr></thead><tbody><tr><td>name</td><td>任务名称。在开始工作流程之前，必须使用Conductor注册为任务类型</td><td></td></tr><tr><td>taskReferenceName</td><td>别名用于在工作流程中引用任务。必须是独一无二的。</td><td></td></tr><tr><td>type</td><td>任务类型。SIMPLE用于远程工作人员或其中一个系统任务类型执行的任务</td><td></td></tr><tr><td>description</td><td>任务描述</td><td>可选的</td></tr><tr><td>optional</td><td>对或错。设置为true时 - 即使任务失败，工作流也会继续。任务的状态反映为COMPLETED_WITH_ERRORS</td><td>默认为 false</td></tr><tr><td>inputParameters</td><td>JSON模板，用于定义给予任务的输入</td><td>有关详细信息，请参见“接线输入和输出”</td></tr></tbody></table><h2 id="3-任务执行"><a href="#3-任务执行" class="headerlink" title="3. 任务执行"></a>3. 任务执行</h2><ul><li>使用接口：<a href="http://localhost:8080/api/workflow/{workname}" target="_blank" rel="noopener">http://localhost:8080/api/workflow/{workname}</a></li><li><p>HTTP方法：POST<br><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/start-workflow.png" alt="1"></p></li><li><p>入参示例</p></li></ul><p>在body中定义参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;type&quot;:&quot;2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-编写用户任务"><a href="#4-编写用户任务" class="headerlink" title="4.编写用户任务"></a>4.编写用户任务</h2><p>目前示例中使用的是HTTP任务，需要编写对应应用rest http接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Task1Worker implements Worker &#123;</span><br><span class="line">    private String taskDefName;</span><br><span class="line"></span><br><span class="line">    public Task1Worker(String taskDefName) &#123;</span><br><span class="line">        this.taskDefName = taskDefName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getTaskDefName() &#123;</span><br><span class="line">        return taskDefName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TaskResult execute(Task task) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.printf(&quot;Executing %s%n&quot;, taskDefName);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(&quot;task：&quot;+ JSON.toJSONString(task));</span><br><span class="line">        System.out.println();</span><br><span class="line">        TaskResult result = new TaskResult(task);</span><br><span class="line">        result.setStatus(TaskResult.Status.COMPLETED);</span><br><span class="line"></span><br><span class="line">        //Register the output of the task</span><br><span class="line">        if(task.getInputData().containsKey(&quot;type&quot;))&#123;</span><br><span class="line">            if(&quot;1&quot;.equals(task.getInputData().get(&quot;type&quot;).toString()))&#123;</span><br><span class="line">                result.getOutputData().put(&quot;id&quot;, &quot;1&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.getOutputData().put(&quot;id&quot;, &quot;-1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result.getOutputData().put(&quot;id&quot;, &quot;-1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;task response：&quot;+ JSON.toJSONString(result));</span><br><span class="line">        System.out.println();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Task2Worker implements Worker &#123;</span><br><span class="line">    private String taskDefName;</span><br><span class="line"></span><br><span class="line">    public Task2Worker(String taskDefName) &#123;</span><br><span class="line">        this.taskDefName = taskDefName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getTaskDefName() &#123;</span><br><span class="line">        return taskDefName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TaskResult execute(Task task) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.printf(&quot;Executing %s%n&quot;, taskDefName);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(&quot;task：&quot;+ JSON.toJSONString(task));</span><br><span class="line">        System.out.println();</span><br><span class="line">        TaskResult result = new TaskResult(task);</span><br><span class="line">        result.setStatus(TaskResult.Status.COMPLETED);</span><br><span class="line"></span><br><span class="line">        if(task.getInputData().containsKey(&quot;id&quot;))&#123;</span><br><span class="line">            if(&quot;1&quot;.equals(task.getInputData().get(&quot;id&quot;).toString()))&#123;</span><br><span class="line">                result.getOutputData().put(&quot;result&quot;, &quot;success&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.getOutputData().put(&quot;result&quot;, &quot;default&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result.getOutputData().put(&quot;result&quot;, &quot;default&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;task response：&quot;+ JSON.toJSONString(result));</span><br><span class="line">        System.out.println();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableHystrix</span><br><span class="line">@EnableAsync //开启异步调用</span><br><span class="line">@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(DemoApplication.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext applicationContext = SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">        logger.info(&quot;渠道端-服务启动完毕！&quot;);</span><br><span class="line"></span><br><span class="line">        TaskClient taskClient = new TaskClient();</span><br><span class="line">        taskClient.setRootURI(&quot;http://localhost:8080/api/&quot;);//Point this to the server API</span><br><span class="line"></span><br><span class="line">        int threadCount = 2;//number of threads used to execute workers.  To avoid starvation, should be same or more than number of workers</span><br><span class="line"></span><br><span class="line">        Worker worker1 = new Task1Worker(&quot;user_task&quot;);</span><br><span class="line">        Worker worker2 = new Task2Worker(&quot;group_task&quot;);</span><br><span class="line"></span><br><span class="line">        //Create WorkflowTaskCoordinator</span><br><span class="line">        WorkflowTaskCoordinator.Builder builder = new WorkflowTaskCoordinator.Builder();</span><br><span class="line">        WorkflowTaskCoordinator coordinator = builder.withWorkers(worker1, worker2).withThreadCount(threadCount).withTaskClient(taskClient).build();</span><br><span class="line"></span><br><span class="line">        //Start for polling and execution of the tasks</span><br><span class="line">        coordinator.init();</span><br><span class="line">        logger.info(&quot;worker启动完毕！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-查看执行结果"><a href="#5-查看执行结果" class="headerlink" title="5. 查看执行结果"></a>5. 查看执行结果</h2><ul><li>调用接口：<a href="http://localhost:8080/api/workflow/{workid}" target="_blank" rel="noopener">http://localhost:8080/api/workflow/{workid}</a></li><li>HTTP方法： GET</li><li>页面查看<br><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/instance-workflow.png" alt="1"></li></ul><p><img src="https://raw.githubusercontent.com/li-shengming/channel-conductor-demo/master/md/img/instance-workflow-detail.png" alt="1"></p><ul><li>输出内容示例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;result&quot;: &quot;default&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-其他工作流【待完善】"><a href="#5-其他工作流【待完善】" class="headerlink" title="5.其他工作流【待完善】"></a>5.其他工作流【待完善】</h2><p>除了线性工作量，conductor还支持很多更加复杂的工作流，如并行工作流、分支工作流等</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>Task和workFlow的定义是放在内存（Memory）里的，服务重启后，信息就丢失了。<ul><li>如果想调整默认配置，可以通过修改com.netflix.conductor.core.config.Configuration类中DB_DEFAULT_VALUE变量值</li></ul></li><li>任务执行记录是存储在ES中的，所以，服务重启后，信息依然存在<h1 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h1><h2 id="Conductor优点"><a href="#Conductor优点" class="headerlink" title="Conductor优点"></a>Conductor优点</h2></li></ul><p>Conductor，帮助我们协调基于微服务的流程，具有以下功能：</p><ul><li>允许创建复杂的流程/业务流，其中由微服务实现单个任务。</li><li>基于JSON DSL的定义执行流程。</li><li>为这些流程提供可见性和可追溯性。</li><li>在暂停，恢复，重启等周围公开控制语义，以获得更好的devops体验。</li><li>允许更多地重用现有的微服务，为管理提供更容易的途径。</li><li>用户界面可视化流程。</li><li>能够在需要时同步处理所有任务。</li><li>能够扩展数百万个并发运行的流程。</li><li>由客户端提取的排队服务支持。</li><li>能够在HTTP或其他传输上运行，例如gRPC。</li></ul><h2 id="为什么不进行点对点编排？"><a href="#为什么不进行点对点编排？" class="headerlink" title="为什么不进行点对点编排？"></a>为什么不进行点对点编排？</h2><p>通过点对点任务编排，我们发现随着业务需求和复杂性的增长难以扩展。发布/订阅模型适用于最简单的流程，<br>但很快就突出了与该方法相关的一些问题：</p><ul><li>流程“嵌入”在多个应用程序的代码中。</li><li>通常，围绕输入/输出，SLA等存在紧密耦合和假设，使得更难以适应不断变化的需求。</li><li>几乎没有办法系统地回答“我们用过程X做了多少”？</li></ul><h2 id="Conductor不足"><a href="#Conductor不足" class="headerlink" title="Conductor不足"></a>Conductor不足</h2><ul><li>定义流程，需要手写DSL文件，对使用者要求太高，需要做前端改造；</li><li>没有介入权限管理功能，需要改造增加</li><li>项目是gradle管理的项目，需要转maven</li><li>配置文件都是本地配置，测试/生产部署的话，需要配置文件做改造</li><li>汉化工作</li><li>技术架构跟目前宜信常用架构、技术栈差距明显，对开发者技术要求较高，间接导致运维难度会更大<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1></li><li><a href="https://blog.csdn.net/wangtongxue123456/article/details/81241210" target="_blank" rel="noopener">服务编排–Conductor</a></li><li><a href="https://www.jianshu.com/p/75b4ac6deb50" target="_blank" rel="noopener">Netflix Conductor源码分析–总体架构介绍</a></li><li><a href="https://www.cnblogs.com/mhc-fly/p/6956305.html" target="_blank" rel="noopener">conductor介绍</a></li><li><a href="https://www.jianshu.com/p/c0611dada7d6" target="_blank" rel="noopener">Netflix Conductor:官方样例搭建</a></li><li><a href="https://blog.csdn.net/cnhome/article/details/80627123" target="_blank" rel="noopener">guice</a></li><li><a href="https://blog.csdn.net/mpren/article/details/86495608" target="_blank" rel="noopener">Netfiex Conductor安装入门指南以及切换为mysql数据源</a></li><li><a href="https://www.cnblogs.com/mhc-fly/p/7010549.html" target="_blank" rel="noopener">CONDUCTOR 系统任务</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Conductor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guice </tag>
            
            <tag> Jetty </tag>
            
            <tag> Flyway </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitbook</title>
      <link href="/public/2019/10/04/gitbook-study/"/>
      <url>/public/2019/10/04/gitbook-study/</url>
      
        <content type="html"><![CDATA[<p>掌握了md语法后，如何构建一本电子书呢，经过调研，其实也特别简单，主要的步骤如下<br><a id="more"></a></p><ul><li>npm下载(淘宝源)：npm –registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> install gitbook-plugin-toggle-chapters</li><li>安装gitbook： npm install -g gitbook-cli</li><li>安装gitbook插件： gitbook install</li><li>gitbook发布：gitbook serve –lrport 35288 –port 4001</li><li>打成war包：jar -cvf  dist.war *  (提前cd到_book目录)</li><li>解压war包：jar -xvf dist.war （rz上传命令）</li><li>上传到服务器上（ip:10.143.135.161,user:yxgly,pwd:Abcd1234）</li><li>寻找nginx配置文件：nginx -t</li><li>重新加载nginx：service nginx reload</li></ul>]]></content>
      
      
      <categories>
          
          <category> Gitbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渠道生产问题整理</title>
      <link href="/public/2019/09/18/channel-pro-problem/"/>
      <url>/public/2019/09/18/channel-pro-problem/</url>
      
        <content type="html"><![CDATA[<p>渠道分布式系统从七月份正式上线以来，从小规模试点（五家营业部），到如今的四百五十家营业部，整体上还是比较平稳的经受住了考研。当然，在这一过渡期中，还是遇到了很多之前没有遇到的困难，幸好的是，我们都及时解决掉了。今天主要对主要问题做下记录<br><a id="more"></a></p><ul><li>docker容器运行一段时间就会出现OOM:docker容器跟jdk低版本不兼容问题（需要保证是jdk1.8 180版本以上）</li><li>基于eureka服务无法做到服务无感知重启：修改eureka默认配置（增加ribbon重试机制&amp;修改docker关闭服务方式（kill -15代替kill -9））</li><li>数据库连接池满了：高并发的情况下，慢sql把连接占用光了，优化sql（覆盖索引&amp;数据跟count分离&amp;大小权限不同查询策略&amp;分表）</li><li>数据库死锁：dbcp数据库驱动连接版本太低，参考连接：<a href="https://blog.csdn.net/wangyangzhizhou/article/details/52149076" target="_blank" rel="noopener">https://blog.csdn.net/wangyangzhizhou/article/details/52149076</a></li><li>容器OOM，使用@async配置的时候，没有配置异步参数，导致高并发的情况下，线程数会不停的创建，极端情况把服务整死了（自定义异步参数配置，增加异步队列，设置异步队列满之后的处理策略）</li><li>数据库同一订单出现重复数据：分布式锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生产问题 </category>
          
          <category> OOM </category>
          
          <category> 数据库连接池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识汇集</title>
      <link href="/public/2019/06/01/index-work/"/>
      <url>/public/2019/06/01/index-work/</url>
      
        <content type="html"><![CDATA[<p>其实，准备面试也是一个不断学习的过程，很多技术要求自己从更加底层的角度去学习，死记硬背是肯定不行的，需要去理解每一个技术，从更高的角度去学习东西。<br><a id="more"></a></p><ul><li>JVM垃圾回收机制：<a href="https://www.toutiao.com/i6691966641242112516/" target="_blank" rel="noopener">https://www.toutiao.com/i6691966641242112516/</a></li><li>蚂蚁金服面试：<a href="https://mp.weixin.qq.com/s/-MzmdxqukOZ6rUta9nkGGw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-MzmdxqukOZ6rUta9nkGGw</a></li><li>JAVA线程池：<a href="https://www.toutiao.com/i6687903955726369287/" target="_blank" rel="noopener">https://www.toutiao.com/i6687903955726369287/</a></li><li>类加载过程：<a href="https://www.toutiao.com/i6691887815241761293/" target="_blank" rel="noopener">https://www.toutiao.com/i6691887815241761293/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识汇集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单体架构&amp;微服务架构</title>
      <link href="/public/2019/05/29/single-to-micro-service/"/>
      <url>/public/2019/05/29/single-to-micro-service/</url>
      
        <content type="html"><![CDATA[<h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>一个项目包（war包）包含了应用的所有功能, 在没有出现微服务概念之前，基本上都是这种架构形式存在， 我们一般把程序打包成一个文件后，扔到tomcat等应用服务器中即可</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>项目架构简单,前期开发的成本低,周期短</li><li>功能都在本地，没有分布式的管理开销和调用开销</li><li>运维简单<br>缺点</li><li>开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断</li><li>代码维护难：代码功能耦合在一起，新人不知道何从下手</li><li>部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</li><li>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉</li><li>扩展性不够：单体应用只能作为一个整体进行扩展，无法结合业务模块的特点进行伸缩</li><li>技术升级难：单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和框架，想要引入新的框架或技术平台会非常困难</li></ul><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。<br>每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API）。<br>每个服务都围绕着具体业务进行构建，并且能够被独立的部署。 </p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>开发简单</li><li>技术栈灵活</li><li>服务独立无依赖</li><li>独立按需扩展</li><li>可用性高</li></ul><p>缺点（挑战）</p><ul><li>系统架构复杂，对开发者要求高</li><li>系统部署依赖</li><li>服务间通信成本</li><li>数据一致性</li><li>系统集成测试</li><li>多服务运维难度</li><li>性能监控</li><li>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单体架构 </tag>
            
            <tag> 微服务架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收机制</title>
      <link href="/public/2019/05/28/garbage-collect-study/"/>
      <url>/public/2019/05/28/garbage-collect-study/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载过程</title>
      <link href="/public/2019/05/28/class-load-study/"/>
      <url>/public/2019/05/28/class-load-study/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？<br><a id="more"></a><br><img src="https://li-shengming.github.io/pictures/classload/class-load-1.jpg" alt="img"></p><p>系统加载 Class 类型的文件主要三步:加载-&gt;连接-&gt;初始化。连接过程又可分为三步:验证-&gt;准备-&gt;解析。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>类加载过程的第一步，主要完成下面3件事情：</p><p>通过全类名获取定义此类的二进制字节流<br>将字节流所代表的静态存储结构转换为方法区的运行时数据结构<br>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口<br>虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="https://li-shengming.github.io/pictures/classload/class-load-2.jpg" alt="img"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><p>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。<br>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。<br>基本数据类型的零值：</p><p>JVM必问知识点:类加载过程<br>基本数据类型的零值</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。</clinit></p><p>对于<clinit>（） 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit>（） 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</clinit></clinit></p><p>对于初始化阶段，虚拟机严格规范了有且只有5中情况下，必须对类进行初始化：</p><p>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<br>使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。<br>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。<br>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。<br>当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。</p><hr><p>原文：<a href="https://www.toutiao.com/i6691887815241761293/" target="_blank" rel="noopener">https://www.toutiao.com/i6691887815241761293/</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql优化</title>
      <link href="/public/2019/05/28/mysql-optimize/"/>
      <url>/public/2019/05/28/mysql-optimize/</url>
      
        <content type="html"><![CDATA[<p>MySQL优化是一个程序员的基本素养，每个程序员基本上都具备，但是，越是简单常见的东西，越容易忽视。如何写出一个高质量的SQL语句其实是非常重要的。<br>在渠道端重构中遇到过一下几个慢SQL场景（线上基本情况：订单量700w+）<br>1）借款查询：借款查询搜索项特别多，仅搜索项就有20+，需要关联五六张表才能满足业务需求，查询效率不高；【单体系统-服务化后，表已经垂直拆分，记录中心维护一张宽表满足需求】<br>2）数据权限问题：线上营业部大概有700+，当查询者拥有营业部权限特别多时，查询效率进一步下降；【基础服务冗余一张权限表，权限数据由sso服务统一维护】<br>3) 大分页跳转问题：选择大分页时，性能极具恶化；【优化sql，使用覆盖索引可以解决这一问题】<br>4) 业务层次优化：为了减小搜索范围，从业务方面去谈，最终确定所有范围查询都带上订单创建时间（默认半年，可以手动扩大）<br>整体的核心思想：就是让索引生效，否则在大数据量的场景下，查询效率一定比较低。至于什么样的sql不走索引，这个就太多了。实际中可以用explain去分析。<br>其他更多mysql优化技巧见后续文章<br><a id="more"></a><br>数据量达到百万级以后，就需要思考如何去优化查询效率了，大致有以下思考方面：</p><ul><li>优化索引&amp;优化SQL（常规手段，优化策略太多了，可以结合explain+慢sql语句去定位分析问题）</li><li>加缓存（数据一致性问题）</li><li>读写分离（如果有必要，可以做读写分离，相当于简单的分库）</li><li>分区（mysql的分区没有oracle性能好）</li><li>分表（垂直拆分和水平拆分，都需要结合业务场景来分析出最合适的拆分策略，拆的不好，反而会起反作用）</li><li>分库（暂时未涉及）</li><li>换NoSql数据库【需要看业务场景，是否能满足】</li></ul><p>其他参考资料</p><ul><li>索引介绍：<a href="https://www.toutiao.com/a6697059671313744387/" target="_blank" rel="noopener">https://www.toutiao.com/a6697059671313744387/</a></li><li>索引原理1：<a href="https://www.toutiao.com/a6682541875695452685/" target="_blank" rel="noopener">https://www.toutiao.com/a6682541875695452685/</a></li><li>索引原理2：<a href="https://www.toutiao.com/a6664353367969497612/" target="_blank" rel="noopener">https://www.toutiao.com/a6664353367969497612/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/public/2019/05/28/thread-pool-study/"/>
      <url>/public/2019/05/28/thread-pool-study/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>参考资料</p><ul><li><a href="https://www.toutiao.com/a6614005147502641671/" target="_blank" rel="noopener">https://www.toutiao.com/a6614005147502641671/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务补偿</title>
      <link href="/public/2019/05/26/distributed-transaction-compensation/"/>
      <url>/public/2019/05/26/distributed-transaction-compensation/</url>
      
        <content type="html"><![CDATA[<p>从单体系统演变成服务化项目后，我们面临的三大难题：服务的拆分、服务故障传播、分布式事务。</p><ul><li>服务的拆分：重点在于架构师对于业务场景的分析和理解，拆分成恰当的粒度，以便未来扩展；</li><li>服务的故障传播：通过ribbon和hytrix基本上可以解决这一问题；</li><li>今天重点想聊得是“分布式事务”问题；<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>这个问题是我在做项目过程中真实经历过的，再深入聊解决方案之前，我想先聊下分布式环境下的两大原理。</li></ul><h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><ul><li>一致性(Consistency) ：客户端知道一系列的操作都会同时发生(生效)</li><li>可用性(Availability)：每个操作都必须以可预期的响应结束</li><li>分区容错性(Partition tolerance)：即使出现单个组件无法可用,操作依然可以完成</li></ul><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><blockquote><p>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>核心思想：先准备资源，然后统一提交执行，类似于数据库上的事务，只不过从数据库提升至业务级别上了，但是实现会更加复杂。</p><p>小结：没有采用这种方案，主要是实现复杂，而且性能还比较低，牺牲了可用性。</p><h3 id="补偿事务"><a href="#补偿事务" class="headerlink" title="补偿事务"></a>补偿事务</h3><p>核心思想：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作，它分为三个阶段：</p><ul><li>Try 阶段主要是对业务系统做检测及资源预留</li><li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ul><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>核心思想：将分布式事务拆分成本地事务进行处理，<br>基本思路就是：</p><ul><li>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</li><li>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</li></ul><h3 id="最终采用的解决方案"><a href="#最终采用的解决方案" class="headerlink" title="最终采用的解决方案"></a>最终采用的解决方案</h3><p>我们吸收了以上主流的解决方案，形成了目前的解决方案，主要思路如下</p><ul><li>首先对当前应用场景进行分析<ul><li>第一步，明确当前场景是否需要进行分布式补偿</li><li>第二步，确定需要补偿的时候，需要业务拆解成不同的步骤</li></ul></li><li>实际执行的时候，第一个步骤比较重要，需要对入参进行严格的参数校验以及其他业务性校验，以保证后续业务需要<ul><li>如果校验未通过，如果是同步接口，直接返回响应错误信息，如果是异步接口，调用异步错误信息通知接口告知调用者；</li><li>如果校验通过，则保存相关业务数据，并且同时生成一条补偿记录；【特别注意：业务数据的保存和补偿记录放在一个数据库事务里】</li></ul></li><li>后续步骤如果出现失败，则更新补偿记录表相关处理状态；</li><li>还需要配置补偿定时任务，每个固定时间扫描补偿信息表，如果发现执行失败记录，则进行重试，如果连续补偿次数达到阈值，则将状态更新为error，停止补偿；</li><li>还需要配置一个人工运维的定时任务，如果发现状态为error并且还未进行邮件预警的记录，则发告警邮件，需要人工运维；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 补偿机制 </tag>
            
            <tag> 技术难点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown画UML图</title>
      <link href="/public/2019/05/10/markdown-uml/"/>
      <url>/public/2019/05/10/markdown-uml/</url>
      
        <content type="html"><![CDATA[<p>使用markdown写作的时候，画UML图是基本诉求。如果通过专业的工具来画，再导成图片引入，整套流程下来特别耗时，如果感觉不合适，再调整，时间周期会更长。</p><p>MarkDown是可以画UML图的，虽然效果没有专业工具好看，但是，掌握基本语法后，会极大提升写作效率。<br><a id="more"></a></p><h2 id="plantUml配置"><a href="#plantUml配置" class="headerlink" title="plantUml配置"></a>plantUml配置</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-plantuml --save</span><br></pre></td></tr></table></figure><h3 id="顺序语法介绍"><a href="#顺序语法介绍" class="headerlink" title="顺序语法介绍"></a>顺序语法介绍</h3><ul><li>关键字start 和stop表示图示的开始和结束</li><li>活动标签(activity label)以冒号开始，以分号结束【:  ;】</li></ul><h4 id="顺序示例代码"><a href="#顺序示例代码" class="headerlink" title="顺序示例代码"></a>顺序示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">start</span><br><span class="line">:配置Java环境; </span><br><span class="line">:下载pantuml.jar;</span><br><span class="line">:编写描述文件; </span><br><span class="line">:执行; </span><br><span class="line">stop</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序示例效果图"><a href="#顺序示例效果图" class="headerlink" title="顺序示例效果图"></a>顺序示例效果图</h4><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXidhPsljyxpglnBB4vtthdovgjbRWidgoe_l5thq5YNabfRavUbc9HTPSLi_tJ7lQDlDPV_-B_HkUJMj_idiRIEMppkKl5lO0MSKb-GK0"><h3 id="if-else语法介绍"><a href="#if-else语法介绍" class="headerlink" title="if-else语法介绍"></a>if-else语法介绍</h3><ul><li>关键字if,then和else设置分支测试，关键字elseif可以设置多个分支</li></ul><h4 id="if-else示例代码"><a href="#if-else示例代码" class="headerlink" title="if-else示例代码"></a>if-else示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">start</span><br><span class="line">if (判断条件) then (yes)</span><br><span class="line">:执行yes操作;</span><br><span class="line">else (no)</span><br><span class="line">:执行no操作;</span><br><span class="line">endif</span><br><span class="line">stop</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="if-else示例效果图"><a href="#if-else示例效果图" class="headerlink" title="if-else示例效果图"></a>if-else示例效果图</h4><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXoanJq7ZQiUJPjBNFvYvyidkRfa99HcgUWaPbQh4cbzMppkKl5lO0sSyczpxPEyUQApMdE5L18oyVBfUN3vVAIybCuoekoIy00000"><h3 id="repeat语法介绍"><a href="#repeat语法介绍" class="headerlink" title="repeat语法介绍"></a>repeat语法介绍</h3><ul><li>可以使用关键字repeat和repeatwhile进行重复循环</li></ul><h4 id="repeat示例代码"><a href="#repeat示例代码" class="headerlink" title="repeat示例代码"></a>repeat示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">start</span><br><span class="line">repeat</span><br><span class="line">:int i=1;</span><br><span class="line">:执行i++;</span><br><span class="line">repeat while (i&lt;=100)</span><br><span class="line">stop</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="repeat示例效果图"><a href="#repeat示例效果图" class="headerlink" title="repeat示例效果图"></a>repeat示例效果图</h4><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXAaejI4qiuRBAp2jHoBGrjEQoUjQv_CN2danjRMkef49vHcPEge96fesjeO619bTnINu10000"><h3 id="while语法介绍"><a href="#while语法介绍" class="headerlink" title="while语法介绍"></a>while语法介绍</h3><ul><li>可以使用关键字while和end while进行while循环;</li></ul><h4 id="while示例代码"><a href="#while示例代码" class="headerlink" title="while示例代码"></a>while示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">start</span><br><span class="line">:i=1;</span><br><span class="line">while(i&lt;100)</span><br><span class="line">:i++;</span><br><span class="line">endwhile</span><br><span class="line">stop</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="while示例效果图"><a href="#while示例效果图" class="headerlink" title="while示例效果图"></a>while示例效果图</h4><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXiigqDRJcAi_8p4dLoBGnD33G10ffQrjpfUQbW4MvYalo2m00"><h3 id="fork语法介绍"><a href="#fork语法介绍" class="headerlink" title="fork语法介绍"></a>fork语法介绍</h3><ul><li>关键字fork，fork again和end fork表示并行处理</li></ul><h4 id="fork示例代码"><a href="#fork示例代码" class="headerlink" title="fork示例代码"></a>fork示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">start</span><br><span class="line">if(条件判断) then (yes)</span><br><span class="line">fork</span><br><span class="line">:并行操作1;</span><br><span class="line">fork again</span><br><span class="line">:并行操作2;</span><br><span class="line">end fork</span><br><span class="line">else(no)</span><br><span class="line">:执行1;</span><br><span class="line">:执行2;</span><br><span class="line">endif</span><br><span class="line">stop</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="fork示例效果图"><a href="#fork示例效果图" class="headerlink" title="fork示例效果图"></a>fork示例效果图</h4><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXoapJU3PtuPFTsvvsB7asRQscGab6Qfw2HcLgiIPNMdvHDfVLqvtRNYpiUJQvzydUEORMO465nFJ4p3nKAIDhhjIy50MmdjISubIDl7nDBgjddSk1Ae3Qe2o8gimqhkAI_080"><ul><li>文本格式注释<ul><li>title 标题，#color 颜色</li><li>使用-&gt;标记，你可以给箭头添加文字或者修改箭头颜色</li></ul></li></ul><h4 id="gt-示例代码"><a href="#gt-示例代码" class="headerlink" title="-&gt;示例代码"></a>-&gt;示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">start</span><br><span class="line">if(条件判断) then (yes)</span><br><span class="line">-[#blue]-&gt;</span><br><span class="line">:执行操作1;</span><br><span class="line">-[#green]-&gt;</span><br><span class="line">:执行操作2;</span><br><span class="line">else(no)</span><br><span class="line">-[#black]-&gt;</span><br><span class="line">:执行1;</span><br><span class="line">endif</span><br><span class="line">stop</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="gt-示例效果图"><a href="#gt-示例效果图" class="headerlink" title="-&gt;示例效果图"></a>-&gt;示例效果图</h4><img src="http://www.plantuml.com/plantuml/svg/Aov9B2hXoapJU3PtuPFTsvvsB7asRQscGab6Qfw2HcLgiIQNRhHoKavfQgok7PVLiyxbBnRsF9lS-sJl74Dha5HwKMfg7eQSaJLNQavngaPUFbH_Od8saYAWrjIybCmqhkAI_080"><h3 id="时序图语法介绍"><a href="#时序图语法介绍" class="headerlink" title="时序图语法介绍"></a>时序图语法介绍</h3><ul><li>用-&gt;来绘制参与者之间传递的消息，用 “–&gt;” 绘制一个虚线箭头表示异步消息<ul><li>用:消息描述</li><li>用关键字actor表示参与者  </li><li>用database标识数据库</li><li>用关键字participant声明参与者</li><li>用#RGB值或者颜色名修改 actor 或参与者的背景颜色</li><li>用self-&gt;self给自己发消息</li><li>用[#RGB]修改箭头颜色-[#red]&gt;或-[#red]-&gt;</li><li>用关键字autonumber用于自动对消息编号</li><li>用skinparam命令改变颜色和字体</li></ul></li></ul><h4 id="时序图示例代码"><a href="#时序图示例代码" class="headerlink" title="时序图示例代码"></a>时序图示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">actor User</span><br><span class="line">participant &quot;流程服务&quot; as A</span><br><span class="line">participant &quot;组合服务&quot; as B</span><br><span class="line">participant &quot;基础服务&quot; as C</span><br><span class="line">User -&gt; A:查询列表</span><br><span class="line">activate A</span><br><span class="line">A -&gt; B: 查询列表</span><br><span class="line">activate B</span><br><span class="line">B -&gt; C: 查询列表</span><br><span class="line">activate C</span><br><span class="line">C --&gt; B: 返回</span><br><span class="line">deactivate C</span><br><span class="line">B--&gt;A:返回</span><br><span class="line">deactivate B</span><br><span class="line">A --&gt; User:返回</span><br><span class="line">deactivate A</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="时序图示例图"><a href="#时序图示例图" class="headerlink" title="时序图示例图"></a>时序图示例图</h4><img src="http://www.plantuml.com/plantuml/svg/IqmkoIzI22rEBU8gI2mgoKpEB4ZCAr5GUhQryVcAxcTpUfzsBLHII2nMS4ILVxwxvUc43YHv9rJvf_DtFL_OW2Jlp0MoH47NJi7HwjdyfI_MBthQCVt5mXLSYSabcMM99Qb06nn1qavM2jZbdRYSGFBEkEITkPmLT246lDW_vUdiULmfgKYIJa0vHojC6IUGjK1j8ETXaNO40000"><h3 id="组件图描述"><a href="#组件图描述" class="headerlink" title="组件图描述"></a>组件图描述</h3><ul><li>组件用[]括号起来</li></ul><h4 id="组件图代码"><a href="#组件图代码" class="headerlink" title="组件图代码"></a>组件图代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">package &quot;包组合&quot; &#123;</span><br><span class="line">    HTTP - [包一组件]</span><br><span class="line">    [包二组件]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node &quot;节点组合&quot; &#123;</span><br><span class="line">    FTP - [节点一组件]</span><br><span class="line">    [包一组件] --&gt; FTP</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cloud &quot;云服务&quot; &#123;</span><br><span class="line">    [云里一]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">database &quot;数据库服务&quot; &#123;</span><br><span class="line">    folder &quot;文件夹组合&quot; &#123;</span><br><span class="line">        [文件夹一]</span><br><span class="line">    &#125;</span><br><span class="line">    frame &quot;帧组合&quot; &#123;</span><br><span class="line">        [帧二]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[包二组件] --&gt; [云里一]</span><br><span class="line">[云里一] --&gt; [文件夹一]</span><br><span class="line">[文件夹一] --&gt; [帧二]</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure><h4 id="组件图示例"><a href="#组件图示例" class="headerlink" title="组件图示例"></a>组件图示例</h4><img src="http://www.plantuml.com/plantuml/svg/AqXCpavCJrLGUjhJ-dntozC97KeArLmAGE0H4XAWeAiG3PHuigC1AFTazxPOi0nOQ5SFJAYMYoilFmLen8kkfkTDEr5DSOCO0f72PWvSI45Nrmwa76HUSav-QOg2qfDT4v_DwNtQjH1cMZHGv6Lx3r0JsDgKn9B4fCHYeDNFfcvurhlkwQx9gEhJydDIKek0qjFQWLOyNOBcEB2HS3cmgI2XMeZUeiHSKBZiM8v54r0K608mvK2de8O9s2_8ZaLYG-HGRKNbGbH0hG00">]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/public/2019/05/06/singleton-design-pattern/"/>
      <url>/public/2019/05/06/singleton-design-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单例模式 (Singleton) 是一种创建型模式，指某个类采用Singleton模式，则在这个类被创建后，只可能产生一个实例供外部访问，并且提供一个全局的访问点。<br><a id="more"></a></p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><img src="http://www.plantuml.com/plantuml/svg/AqXCpavCJrLGIiv9B2vM2CxCIyz9BSdFqtZQE_N9lkvdAnO-tTElgQHGpSMb00Hegi1YrM1IEpsrn3Elk2GnBpbLGzCALOakmbnDi40jcCpBBqbLACfCpoYnKe3OztpZRgvQ0000"><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。getInstance()的返回值是一个同一个对象的引用，并不是一个新的实例</p><p>1) 饿汉式<br>特点：线程安全，无法实现实例懒加载策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton1 &#123;</span><br><span class="line"></span><br><span class="line">    private final static Singleton1 singleton1 = new Singleton1();</span><br><span class="line"></span><br><span class="line">    private Singleton1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton1 getInstance() &#123;</span><br><span class="line">        return singleton1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2) 懒汉式<br>特点：线程不安全，实现了实例懒加载策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton2 &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton2 singleton2;</span><br><span class="line"></span><br><span class="line">    private Singleton2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton2 getInstance() &#123;</span><br><span class="line"></span><br><span class="line">        if (singleton2 == null)</span><br><span class="line">            singleton2 = new Singleton2();</span><br><span class="line">        return singleton2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3) 全局锁式<br>特点：线程安全，且实现了懒加载策略，但是线程同步时效率不高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton3 singleton3;</span><br><span class="line"></span><br><span class="line">    private Singleton3() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized static Singleton3 getInstance() &#123;</span><br><span class="line"></span><br><span class="line">        if (singleton3 == null)</span><br><span class="line">            singleton3 = new Singleton3();</span><br><span class="line">        return singleton3;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4) 双重校验锁式<br>   特点：线程安全，且实现了懒加载策略，同时保证了线程同步时的效率；实现复杂，且 volatile 需要在JDK1.5之后的版本才能确保安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton4 &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Singleton4 singleton4;</span><br><span class="line"></span><br><span class="line">    private Singleton4() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton4 getInstance() &#123;</span><br><span class="line"></span><br><span class="line">        if (singleton4 == null) &#123;</span><br><span class="line">            synchronized (Singleton4.class) &#123;</span><br><span class="line">                if (singleton4 == null) &#123;</span><br><span class="line">                    singleton4 = new Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="为什么加volatile修饰？"><a href="#为什么加volatile修饰？" class="headerlink" title="为什么加volatile修饰？"></a>为什么加volatile修饰？</h3><blockquote><p>多线程场景下，如果不增加volatile，还是可能存在工作线程里的副本已经初始化了实例，但是主线程的实例还是空，此时如果有其他线程恰好同时请求该实例，还是会再次初始化。</p></blockquote><p>5) 静态代码块式<br>   特点：线程安全，类主动加载时才初始化实例，实现了懒加载策略，且线程安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton5 &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton5 singleton5;</span><br><span class="line"></span><br><span class="line">    private Singleton5() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        singleton5 = new Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton5 getInstance() &#123;</span><br><span class="line">        return singleton5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6) 静态内部类式<br>特点：线程安全，不存在线程同步问题，且单例对象在程序第一次 getInstance() 时主动加载 SingletonHolder 和其 静态成员 INSTANCE，因而实现了懒加载策略；多创建了一个类；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton6 &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton6() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton6 INSTANCE = new Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton6 getInstance() &#123;</span><br><span class="line">        return Singleton6.SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7) 枚举方式<br>特点：线程安全，不存在线程同步问题，且单例对象在枚举类型 INSTANCE 第一次引用时通过枚举的 构造函数 初始化，因而实现了懒加载策略；可以防止反序列化；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton7 &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton7() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enum SingletonEnum &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        private final Singleton7 singleton7;</span><br><span class="line"></span><br><span class="line">        private SingletonEnum() &#123;</span><br><span class="line">            singleton7 = new Singleton7();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton7 getInstance() &#123;</span><br><span class="line">        return SingletonEnum.INSTANCE.singleton7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="推荐使用哪一种？"><a href="#推荐使用哪一种？" class="headerlink" title="推荐使用哪一种？"></a>推荐使用哪一种？</h3><p>这个问题我觉得没有标准答案，需要根据实际的业务场景进行分析。</p><ul><li>如果这个单例类初始化开销很低，那么第一种最好，代码简单清晰，线程安全；</li><li>如果这个单例类初始化开销很大，要求一定要在实际使用时才初始化<ul><li>如果当前应用环境不是多线程环境，那么第二种最好，代码简单，而且效率高；</li><li>如果是多线程环境，并且单例类中只有这一个方法需要枷锁处理，那么第三种最好；</li><li>如果这个单例类中，很多方法都要加锁处理，那么方法级的加锁，会影响效率，所以第四、五、六种选择也不错；</li><li>如果单例模式的使用场景更加复杂，如还可能通过反射或者反序列化获取单例实例，那么采用第七种，或者四、五、六在加一部分防止反射和反序列化的代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Singleton() &#123;</span><br><span class="line">    // 防止反射获取多个对象的漏洞</span><br><span class="line">    if (null != instance) &#123;</span><br><span class="line">         throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 防止反序列化获取多个对象的漏洞。</span><br><span class="line">// 无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。</span><br><span class="line">// 实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象。</span><br><span class="line">private Object readResolve() throws ObjectStreamException &#123;  </span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p>优点</p><ul><li>单例模式在内存中只有一个实例，减少了内存开支，尤其是频繁的创建和销毁实例。</li><li>由于只生成一个实例，所以减少了系统的性能开销。</li><li>避免对资源的多重占用，例如写文件操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问</li></ul><p>缺点</p><ul><li>单例模式对测试不利。</li><li>单例模式与单一职责原则有冲突，一个类应该只实现一个逻辑，而不用关心它是否是单例的。<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2></li><li>Spring里的@Service，@Component等注释的bean，默认都是单例<ul><li>编程的时候一定要注意到这一点，一些新手容易忽视这一点，容易在单例类中加一些私有变量，在单例模式下，这些私有变量都是共享资源，多线程环境下使用时容易出问题</li><li>尽量把业务实现尽量做成“无状态”的，这样容易做负载均衡，支持更高的并发</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/public/2019/05/04/oula/"/>
      <url>/public/2019/05/04/oula/</url>
      
        <content type="html"><![CDATA[<p><strong>对正整数n，欧拉函数是小于n且和n互质的正整数(包括1)的个数</strong>。</p><blockquote><p>例如Euler(8)=4，因为1,3,5,7均和8互质,下面用E(n)表示欧拉函数的值。<br>​&gt; 在数论中，对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。</p></blockquote><a id="more"></a><p>​    φ函数的值：</p><p>$$<br>φ(x)=x(1- \frac 1{p(1)})(1- \frac1{p(2)})(1-\frac1{p(3)})(1-\frac1{p(4)})…..(1-\frac1{p(n)})<br>$$<br>​    其中p(1),p(2)…p(n)为x的所有质因数;</p><p>​    φ(1)=1(唯一和1互质的数，且小于等于1)。注意：每种质因数只有一个。</p><p>​     例如:</p><p>​         φ(10)=10×(1-1/2)×(1-1/5)=4; 分别为：1 3 7 9</p><p>​         φ(30)=30×(1-1/2)×(1-1/3)×(1-1/5)=8;</p><p>​         φ(49)=49×(1-1/7)=42;</p><h3 id="欧拉函数的性质："><a href="#欧拉函数的性质：" class="headerlink" title="欧拉函数的性质："></a>欧拉函数的性质：</h3><ol><li><p>对于素数p，φ(p) = p-1，对于两个素数p,q，φ(pq) = pq-1。</p><p>欧拉函数是积性函数，但不是完全积性函数。即φ(mn)=φ(m)*φ(n)，只有(n,m)=1时成立。</p></li><li><p>对于一个正整数N的素数幂分解$N = {P_1}^{q^1}<em>{P_2}^{q^2}</em>…*{P_n}^{q^n}$。</p><p>$φ(x)=x(1- \frac 1{p(1)})(1- \frac1{p(2)})(1-\frac1{p(3)})(1-\frac1{p(4)})…..(1-\frac1{p(n)})$</p></li><li><p>除了N=2，φ(N)都是偶数。</p></li><li><p>设N为正整数，$\sumφ(d) = N(d|N)$。</p></li></ol><p>根据性质2，我们可以在(sqrt(n))的时间内求一个数的欧拉函数值。</p><p>延伸：一个数的所有质因子之和是euler(n)*n/2。</p><p>欧拉函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//直接求小于或等于n,且与n互质的个数:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=x;</span><br><span class="line">    <span class="keyword">int</span> n=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(x*<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">//如果判断条件改为i*i&lt;=n,这里的i*i就会做sqrt(n)次,每次循环都要算一次，养成好习惯 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        ret=ret/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法防止溢出(ret=ret*(1-1/p(i)))</span></span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">          n/=i;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">          ret=ret/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//筛选模板:求[1,n]之间每个数的质因数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1000001</span></span><br><span class="line"><span class="keyword">int</span> euler[size];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">memset</span>(euler,<span class="number">0</span>,<span class="keyword">sizeof</span>(euler));</span><br><span class="line">     euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;size;i++)</span><br><span class="line">       <span class="keyword">if</span>(!euler[i])</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;size;j+=i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(!euler[j])</span><br><span class="line">               euler[j]=j;</span><br><span class="line">               euler[j]=euler[j]/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法是为了防止中间数据的溢出</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Study</title>
      <link href="/public/2019/05/03/redis-study/"/>
      <url>/public/2019/05/03/redis-study/</url>
      
        <content type="html"><![CDATA[<p> Redis是当前比较热门的NOSQL系统之一，它是一个开源的使用ANSI c语言编写的key-value存储系统（区别于MySQL的二维表格的形式存储。）。和Memcache类似，但很大程度补偿了Memcache的不足。和Memcache一样，Redis数据都是缓存在计算机内存中，不同的是，Memcache只能将数据缓存到内存中，无法自动定期写入硬盘，这就表示，一断电或重启，内存清空，数据丢失。所以Memcache的应用场景适用于缓存无需持久化的数据。而Redis不同的是它会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，实现数据的持久化.<br><a id="more"></a></p><h2 id="Redis的机制"><a href="#Redis的机制" class="headerlink" title="Redis的机制"></a>Redis的机制</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>Redis最牛逼的地方就是快，为什么这么快呢，主要原因如下</p><ul><li>纯内存操作</li><li>数据结构简单，对数据操作也简单</li><li><p>单线程操作，避免了频繁的上下文切换<br>  单线程好处：1.代码更清晰，处理逻辑更简单；2.不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；3.不存在多进程或者多线程导致的切换而消耗CPU<br>  单线程劣势：无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</p></li><li><p>采用了<a href="https://blog.csdn.net/happy_wu/article/details/80052617" target="_blank" rel="noopener">非阻塞I/O多路复用机制</a><br>  IO多路复用是需要操作系统支持的，目前，提供的多路复用函数库主要有四下个方法<a href="https://www.cnblogs.com/skiler/p/6852493.html" target="_blank" rel="noopener">select、poll、epoll、kqueue等</a><br>  名词比较绕口，理解涵义就好。从网上抄来的一个epoll场景：<br>  一个酒吧服务员（一个线程），前面趴了一群醉汉，突然一个吼一声“倒酒”（事件），你小跑过去给他倒一杯，然后随他去吧，突然又一个要倒酒，你又过去倒上，就这样一个服务员服务好多人，有时没人喝酒，服务员处于空闲状态，可以干点别的玩玩手机。至于epoll与select，poll的区别在于后两者的场景中醉汉不说话，你要挨个问要不要酒，没时间玩手机了。epoll是linux下内核支持的函数，而kqueue是其他系统支持的函数。io多路复用大概就是指这几个醉汉共用一个服务员。</p></li></ul><h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><p>了解一个技术的时候，一定要自己不断的去思考，为什么会出现这个技术，这个技术解决了什么问题，以及怎样解决的。<br>Redis还有一个很牛逼的特性就是高可用性，Redis是如何做到的呢，主要原因如下</p><ul><li>支持持久化机制，用于解决机器故障导致内存数据丢失的问题</li><li>支持主从复制，用于解决读取数据压力大问题</li><li>支持哨兵机制，能够及时做到故障转移</li><li>支持集群机制，能够扩充Redis可以存放的数据量</li><li>支持过期策略以及内存淘汰机制，解决写入数据高于Redis总内存问题</li><li>事务控制和分布式锁，保证并发场景下正常的使用Redis</li></ul><p>下面依次分析这几个机制</p><h3 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h3><p>持久化作用<br>Redis持久化就是按照一定的机制及时将内存里的数据同步至磁盘。<br>为什么要去支持持久化呢？<br>Redis之前比较流行的内存数据库是memcached，由于它的数据都存储到内存里了，就导致它有一个很致命的缺陷，就是一旦机制出现故障，所有数据就会丢失，这一点就一定决定了memcached的应用场景会非常受限，只能应用于一些非核心业务，可以接受数据丢失。<br>持久化机制</p><ul><li>RDB<br>可以在指定的时间间隔内生成数据集的时间点快照</li><li>AOF<br>持久化记录服务器执行的所有写操作命令</li><li>同时启用AOF和RDB<br>当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。为了缓解这一问题，Redis支持Rewrite重写，简单的讲就是基于一定算法，给Aof文件“瘦身”。</li></ul><p>优缺点分析</p><ul><li><p>RDB Redis会单独启动一个进程，先把数据收集到一个临时文件，等待上一个持久化操作结束后，并且按照你配置的持久策略去把数据同步到磁盘，对主进程无影响，性能高，但是缺点是，一旦出现机器故障，放在缓存里的数据就会丢失。<br>RDB策略配置示例如下（redis.conf）<br>每900s有一次写操作触发同步，或者每300s有10次写操作触发同步，或者每60s有10000次操作触发同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></li><li><p>AOF Redis会将自己所有执行过的更新指令记录下来，并且日志文件只允许尾部添加操作。恢复数据的时候，Redis会从头到尾重新执行一遍。<br>Aof目前同步策略：Always（每步）Everysec（每一秒）No（操作系统决定）。<br>开启aof配置，以及同步策略配置示例如下（redis.conf）<br>开启aof，每秒同步一次写操作到磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes </span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure></li></ul><p>这两种机制没有好坏之说，使用的时候，需要你去分析自己的实际业务场景，哪个适合用哪个！<br>参考链接：<a href="https://www.cnblogs.com/shsxt/p/7911591.html" target="_blank" rel="noopener">Redis持久化</a></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>作用<br>Redis相对于传统的db，读写非常快的，但是，面对更大的读请求来临时，Redis提供了主从复制策略来解决读取数据压力大问题<br>结构<br>Redis 主从master-slave级联图</p><p><img src="https://li-shengming.github.io/pictures/redis/redis-master-slave.png" alt="redis-master-slave"></p><p><strong>主从同步策略</strong></p><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。<br>开启从服务器配置（redis.conf）<br>将当前服务器配置成192.168.1.1 6379 这个节点的从服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://www.cnblogs.com/hepingqingfeng/p/7263782.html" target="_blank" rel="noopener">主从复制</a></p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>如果Redis主节点跪了的话，如何来保证Redis系统可用性呢？Redis提供了哨兵机制，哨兵会去监控Redis节点，当发现Redis主节点跪了的时候，会通过投票机制，从从节点中挑取一个节点自动升级为主节点，自动实现故障转移，同事还会向管理员发送Redis节点异常通知。<br>结构<br>Redis 哨兵监控图(哨兵也可以多个)<br><img src="https://li-shengming.github.io/pictures/redis/redis-sentinel.png" alt="redis-master-slave"><br><strong>哨兵原理介绍</strong></p><p>首先理解两个名词</p><ul><li>主观下线：当前哨兵节点连接某一Redis节点失败；</li><li><p>客观下线：当sentinel监视的某个服务主观下线后，sentinel会询问其它监视该服务的sentinel，看它们是否也认为该服务主观下线，接收到足够数量（这个值可以配置）的sentinel判断为主观下线，既任务该服务客观下线，并对其做故障转移操作。<br>选举领头哨兵</p><p>一个redis服务被判断为客观下线时，多个监视该服务的sentinel协商，选举一个领头sentinel，对该redis服务进行古战转移操作。选举领头sentinel会遵循一些规则，有兴趣可以自行调研。<br>  注：你可能会关心为啥选举领头哨兵，其实道理很简单，做故障迁移的时候，不可能每个哨兵节点都私自决定用哪个节点替代坏掉的主节点，<br>  会乱套的，公平的投出一个节点作为领头者，然后基于一定规则去做故障转移最快<br>进行故障转移，分为三个主要步骤：<br>1) 从下线的主服务的所有从服务里面挑选一个从服务，将其转成主服务；<br>2) 已下线主服务的所有从服务改为复制新的主服务；<br>3) 将已下线的主服务设置成新的主服务的从服务，当其回复正常时，复制新的主服务，变成新的主服务的从服务。<br>参考链接：<a href="https://blog.csdn.net/RobertoHuang/article/details/70768922" target="_blank" rel="noopener">Redis哨兵</a></p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>作用<br>一台Redis节点内存资源总是有限的，如果不够使的话，怎么能扩展吗？<br>Redis是支持集群的，默认关闭。<br>开启集群配置(redis.conf)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes #开启cluster</span><br></pre></td></tr></table></figure></li></ul><p>Redis集群架构<br><img src="https://li-shengming.github.io/pictures/redis/redis-cluster.png" alt="redis-cluster"><br>图上能看到的信息：<br>1) 对象保存到Redis之前先经过CRC16哈希到一个指定的Node上，例如Object4最终Hash到了Node1上。<br>2) 每个Node被平均分配了一个Slot段，对应着0-16384，Slot不能重复也不能缺失，否则会导致对象重复存储或无法存储。<br>3) Node之间也互相监听，一旦有Node退出或者加入，会按照Slot为单位做数据的迁移。例如Node1如果掉线了，0-5640这些Slot将会平均分摊到Node2和Node3上,由于Node2和Node3本身维护的Slot还会在自己身上不会被重新分配，所以迁移过程中不会影响到5641-16384Slot段的使用。</p><p>简单总结下哈希Slot的优缺点：</p><ul><li>优点：将Redis的写操作分摊到了多个节点上，提高写的并发能力，扩容简单。</li><li>缺点：每个Node承担着互相监听、高并发数据写入、高并发数据读出，工作任务繁重</li></ul><p>延展性问题：redis为什么采用一致性hash，而没有采用传统的取模算法？<br>其实道理很简答，因为在集群环境下，新增节点或者节点失效是很常见的，如果采用取模的那种算法，每次新增或者删除节点时，所有与数据都可能需要重新调整位置，这是无法接受的！<br>结合redis集群和主从复制两种思想，可以得到Redis集群的最终形态</p><p><img src="https://li-shengming.github.io/pictures/redis/redis-cluster-final.png" alt="redis-cluster-final"></p><p>想扩展并发读就添加Slaver，想扩展并发写就添加Master，想扩容也就是添加Master，任何一个Slaver或者几个Master挂了都不会是灾难性的故障。完美！<br>参考链接：<a href="https://blog.csdn.net/yejingtao703/article/details/78484151" target="_blank" rel="noopener">Redis集群设计原理</a></p><h3 id="内存数据管理方案"><a href="#内存数据管理方案" class="headerlink" title="内存数据管理方案"></a>内存数据管理方案</h3><p>作用<br>这一部分对应的问题很常见，就是如果你的redis只能存5g数据，可是你写入了10g数据，那么内存里最终会保留哪5g数据的问题。<br>redis采用的是定期删除+惰性删除策略。</p><p><strong>为什么不用定时删除策略?</strong><br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p><p><strong>定期删除+惰性删除是如何工作的呢?</strong><br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><p><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在redis.conf中有一行配置示例(当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://www.cnblogs.com/rjzheng/p/9096228.html" target="_blank" rel="noopener">分布式之redis复习精讲</a></p><h3 id="Redis事务和分布式锁"><a href="#Redis事务和分布式锁" class="headerlink" title="Redis事务和分布式锁"></a>Redis事务和分布式锁</h3><p>Redis事务<br>核心操作：multi开启事务，exec执行事务，discard撤销事务，watch监控key是否改过、UNWATCH对应watch操作【multi和exec执行后会自动unwatch调监控队列里的所有key，如果想提前释放，可以用这个命令】</p><p>redis事务采用的是乐观锁，就是先处理，再真正去执行的时候去看有没有被修改过，没有的话，就去更新，否则报错。这个思想是不是有点似曾相识，是的，concurrenthashmap的set值时也是用的这个思想。还是那句话，虽然技术上感觉不搭边，但是思想上确实想通的。</p><p>Redis分布式锁<br>核心操作：setNX，理解这个操作基本上就理解了分布式锁。这个方法的意思就是去给一个key“赋值”，如果之前没人这样做过，返回值是1，否则返回0.</p><p>参考链接：<a href="https://www.cnblogs.com/Jason-Xiang/p/5364252.html" target="_blank" rel="noopener">Redis事务和分布式锁</a></p><h2 id="Redis的缺点"><a href="#Redis的缺点" class="headerlink" title="Redis的缺点"></a>Redis的缺点</h2><p>Redis会是完美的程序吗？肯定不可能的，世界上就没有完美的东西。我们需要做的事情，分析清楚事物的主要矛盾，在实际开发中，不要犯这些错误就好了。</p><p>以下典型问题，重点参考了<a href="https://www.cnblogs.com/rjzheng/p/9096228.html" target="_blank" rel="noopener">分布式之redis复习精讲</a></p><h3 id="缓存和数据库双写一致性问题"><a href="#缓存和数据库双写一致性问题" class="headerlink" title="缓存和数据库双写一致性问题"></a>缓存和数据库双写一致性问题</h3><p>问题说明<br>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。<br>解决方案<br>详细解决方案见<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析</a></p><h3 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h3><p>缓存击穿问题和缓存雪崩问题都是大项目中可能会遇到，小项目比较难遇到。<br>问题说明<br>黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常<br>解决方案<br>1) 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试<br>2) 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。<br>3) 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p><h3 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h3><p>问题说明<br>缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常<br>解决方案<br>1) 给缓存的失效时间，加上一个随机值，避免集体失效。<br>2) 使用互斥锁，但是该方案吞吐量明显下降了。<br>3) 双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点</p><ul><li>I 从缓存A读数据库，有则直接返回</li><li>II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</li><li>III 更新线程同时更新缓存A和缓存B。</li></ul><h3 id="缓存的并发竞争问题"><a href="#缓存的并发竞争问题" class="headerlink" title="缓存的并发竞争问题"></a>缓存的并发竞争问题</h3><p>问题说明<br>这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。<br>解决方案<br>1) 如果对这个key操作，不要求顺序<br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>2) 如果对这个key操作，要求顺序<br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳</p><hr><p>参考链接：<a href="https://www.toutiao.com/i6688926152364392963/" target="_blank" rel="noopener">https://www.toutiao.com/i6688926152364392963/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SourceCode </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka Study</title>
      <link href="/public/2019/05/02/eureka-study/"/>
      <url>/public/2019/05/02/eureka-study/</url>
      
        <content type="html"><![CDATA[<p>Eureka是基于REST（Representational State Transfer）服务，主要以AWS云服务为支撑，提供服务发现并实现负载均衡和故障转移。我们称此服务为Eureka服务。Eureka提供了Java客户端组件，Eureka Client，方便与服务端的交互。客户端内置了基于round-robin实现的简单负载均衡。在Netflix，为Eureka提供更为复杂的负载均衡方案进行封装，以实现高可用，它包括基于流量、资源利用率以及请求返回状态的加权负载均衡。</p><a id="more"></a><h3 id="Eureka介绍"><a href="#Eureka介绍" class="headerlink" title="Eureka介绍"></a>Eureka介绍</h3><p>Eureka包含了服务器端和客户端组件。</p><ul><li>服务器端，也被称作是服务注册中心，用于提供服务的注册与发现。Eureka支持高可用的配置，当集群中有分片出现故障时，Eureka就会转入自动保护模式，它允许分片故障期间继续提供服务的发现和注册，当故障分片恢复正常时，集群中其他分片会把他们的状态再次同步回来。</li><li>客户端组件包含服务消费者与服务生产者。在应用程序运行时，Eureka客户端并把他们缓存到本地并周期性的刷新服务状态。</li></ul><h3 id="Eureka原理"><a href="#Eureka原理" class="headerlink" title="Eureka原理"></a>Eureka原理</h3><p><img src="https://li-shengming.github.io/pictures/eureka/eureka-operate.png" alt="Eureka原理"></p><ul><li>第一步，spider会启动一个新的docker容器，并在新容器上部署被启动服务的镜像，然后启动服务；<ul><li>如果采用的是SpringCloud框架，新起的服务会马上把信息注册到EUREKA上；</li><li>如果是非SpringCloud，周期性（默认30s，可通过eureka.client.instance-info-replication-interval-seconds调整）的将信息注册到EUREKA上；</li></ul></li><li>第二步，EUREKA收到客户端上报的注册信息后，将新注册服务信息放到readWriteCacheMap中，同时周期性（默认30s，可通过eureka.server.response-cache-update-interval-ms调整）的将信息刷新到缓存中（readOnlyCacheMap）中<ul><li>客户端拉取信息是从缓存（readOnlyCacheMap）中拉取的【readOnlyCacheMap这个可通过eureka.server.use-read-only-response-cache=false关闭的，由于目前EUREKA是公用的，基础研发部反馈，默认配置是不能动的】；</li><li>如果你通过web页面去查看eureka上客户端的注册信息，看到的数据是readWriteCacheMap中的，也就是说，你即便在页面上看到了新启动服务的信息，也不代表调用方已经获取到了最新的实例信息；</li></ul></li><li>第三步，客户端会定期（默认30s,可通过eureka.client.registry-fetch-interval-seconds调整）从EUREKA上拉取最新的注册信息</li><li>第四步，如果客户端采用了ribbon进行负载均衡，ribbon使用ribbon缓存进行负载均衡，客户端会定期（默认30s,可通过ribbon.ServerListRefreshInterval进行调整）最新拉取到的信息同步到ribbon缓存</li></ul><p>理解了以上四步，我们思考一个问题，新服务上线，客户端最大可能多久可以拿到最新的服务信息</p><ul><li>SpringCloud下=0(首次注册 init registe) + 30(readOnlyCacheMap)+30(client fetch interval)+30(ribbon)=90</li><li>非SpringCloud下=30(首次注册 init registe) + 30(readOnlyCacheMap)+30(client fetch interval)+30(ribbon)=120</li></ul><p>结论：90s的延迟，完全可能存在这样的场景：新服务已经起来了，老服务已经关闭，但是客户端由于没有拿到最新的地址信息，导致服务出现中断问题。</p><p>上面只分析了服务上线的情况，还有服务下线的情况，如果没有做特殊配置的话，EUREKA连续3个心跳周期没有检测到客户端心跳的话，会将这一节点剔除，客户端获取到服务不可用的信息会更晚。</p><p>网上查到的资料提醒：现在eureka自动下线存在BUG,自动剔除时间会翻倍，需要6个周期，最长要270s</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术难点 </tag>
            
            <tag> Eureka </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/public/2019/05/01/hello-world/"/>
      <url>/public/2019/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
